// Generated by CoffeeScript 1.6.3
(function() {
  var God, Grass, Particles, pass, __DEBUG__;

  __DEBUG__ = false;

  pass = void 0;

  God = (function() {
    function God() {}

    God.setup = function() {
      var c, i;
      this.deviceWidth = 640.0;
      this.deviceHeight = 480.0;
      this.scene = new THREE.Scene();
      this.scene.fog = new THREE.FogExp2(0x000000, 0.03);
      this.camera = new THREE.PerspectiveCamera(90, this.deviceWidth / this.deviceHeight, Math.pow(0.1, 8), Math.pow(10, 3));
      this.renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this.renderer.setSize(this.deviceWidth, this.deviceHeight);
      this.renderer.setClearColor(0x444499, 0);
      c = document.getElementById('c');
      c.appendChild(this.renderer.domElement);
      this.grasses = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 500; i = ++_i) {
          _results.push(new Grass(this.scene));
        }
        return _results;
      }).call(this);
      return this.particles = new Particles(this.scene);
    };

    God.start = function() {
      var render, startTime,
        _this = this;
      startTime = +new Date();
      render = function() {
        var grass, _i, _len, _ref;
        _this.tick = new Date() - startTime;
        _ref = _this.grasses;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          grass = _ref[_i];
          grass.update();
        }
        _this.camera.position.z = Math.sin(_this.tick * 0.0005) * 5;
        _this.camera.position.y = Math.sin(_this.tick * 0.0005) * 2 + 2.0;
        _this.camera.position.x = Math.cos(_this.tick * 0.0005) * 5;
        _this.camera.lookAt(new THREE.Vector3(0, 3, 0));
        requestAnimationFrame(render);
        _this.renderer.render(_this.scene, _this.camera);
        return _this.particles.update();
      };
      return render();
    };

    return God;

  })();

  Grass = (function() {
    var Bone;

    Bone = (function() {
      function Bone(index, p) {
        this.index = index;
        this.position = new THREE.Vector3();
      }

      return Bone;

    })();

    function Grass(scene) {
      var color, i, index, m, r, th, v, vi, _i, _j, _len, _ref, _ref1;
      this.scene = scene;
      m = 12;
      r = Math.cos(Math.random() * 1.55) * 15;
      th = Math.random() * 100;
      this.position = new THREE.Vector3(r * Math.sin(th), 0, r * Math.cos(th));
      this.bones = (function() {
        var _i, _results;
        _results = [];
        for (index = _i = 0; 0 <= m ? _i < m : _i > m; index = 0 <= m ? ++_i : --_i) {
          _results.push(new Bone(index, this.position));
        }
        return _results;
      }).call(this);
      this.height = Math.random() * 0.2 + 0.1;
      this.geometry = new THREE.Geometry();
      _ref = this.bones;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        v = _ref[i];
        this.geometry.vertices.push(new THREE.Vector3(-1, i, 0), new THREE.Vector3(1, i, 0));
      }
      for (i = _j = 0, _ref1 = m - 1; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        vi = i * 2;
        this.geometry.faces.push(new THREE.Face3(vi, vi + 1, vi + 2), new THREE.Face3(vi + 1, vi + 3, vi + 2));
        this.geometry.faceVertexUvs[0].push([new THREE.Vector2(1.0, 0.0), new THREE.Vector2(0.0, 0.0), new THREE.Vector2(1.0, 1.0)], [new THREE.Vector2(0.0, 0.0), new THREE.Vector2(0.0, 1.0), new THREE.Vector2(1.0, 1.0)]);
      }
      color = new THREE.Color();
      this.material = new THREE.MeshBasicMaterial({
        color: color,
        map: this.makeTexture(),
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending,
        transparent: true,
        depthTest: false
      });
      this.mesh = new THREE.Mesh(this.geometry, this.material);
      this.scene.add(this.mesh);
    }

    Grass.prototype.makeTexture = function() {
      var ctx, grad, height, width;
      if (!Grass.texture) {
        this.canvas = document.createElement('canvas');
        width = this.canvas.width = 128;
        height = this.canvas.height = 128;
        ctx = this.canvas.getContext('2d');
        grad = ctx.createLinearGradient(0, 0, width, 0);
        grad.addColorStop(0, 'rgb(0, 0, 0)');
        grad.addColorStop(0.39, 'rgb(32, 64, 32)');
        grad.addColorStop(0.4, 'rgb(192, 255, 192)');
        grad.addColorStop(0.5, 'rgb(160, 160, 160)');
        grad.addColorStop(0.6, 'rgb(192, 255, 192)');
        grad.addColorStop(0.61, 'rgb(32, 64, 32)');
        grad.addColorStop(1, 'rgb(0, 0, 0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.rect(0, 0, width, height);
        ctx.fill();
        Grass.texture = THREE.ImageUtils.loadTexture(this.canvas.toDataURL());
        if (__DEBUG__) {
          document.body.appendChild(this.canvas);
        }
      }
      return Grass.texture;
    };

    Grass.prototype.update = function() {
      var bone, i, k, p, s, t, w, y, _i, _j, _len, _len1, _ref, _ref1;
      k = this.height;
      y = 0;
      t = 0;
      _ref = this.bones;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        bone = _ref[i];
        k *= 0.98;
        bone.position.set(0, Math.cos(t) * y, Math.sin(t) * y);
        t += Math.sin(God.tick * 0.001 + y * 0.1 + (this.position.x + this.position.z) * 0.01) * 0.03 + 0.005;
        y += k;
      }
      _ref1 = this.bones;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        bone = _ref1[_j];
        i = bone.index;
        p = bone.position;
        s = new THREE.Vector3(this.height * 3, 0, 0);
        w = Math.cos(1.0 * i / this.bones.length * Math.PI / 2) * 0.1;
        s.multiplyScalar(w);
        this.geometry.vertices[i * 2 + 0].set(p.x + s.x + this.position.x, p.y + s.y + this.position.y, p.z + s.z + this.position.z);
        this.geometry.vertices[i * 2 + 1].set(p.x - s.x + this.position.x, p.y - s.y + this.position.y, p.z - s.z + this.position.z);
      }
      return this.geometry.verticesNeedUpdate = true;
    };

    return Grass;

  })();

  Particles = (function() {
    var TYPE;

    TYPE = {
      tp1: 500,
      tp2: 1000,
      tp3: 1500,
      numTypes: 3,
      to: function(index) {
        if (index < 0) {
          return 0;
        } else if (index < TYPE.tp1) {
          return TYPE.tp1;
        } else if (index < TYPE.tp2) {
          return TYPE.tp2;
        } else if (index < TYPE.tp3) {
          return TYPE.tp3;
        } else {
          return TYPE.maxIndex;
        }
      },
      ind: function(index) {
        if (index === 0) {
          return TYPE.tp1;
        } else if (index === 1) {
          return TYPE.tp2;
        } else if (index === 2) {
          return TYPE.tp3;
        } else {
          return 0;
        }
      },
      size: function(index) {
        if (index === 0) {
          return TYPE.tp1 - 0;
        } else if (index === 1) {
          return TYPE.tp2 - TYPE.tp1;
        } else if (index === 2) {
          return TYPE.tp3 - TYPE.tp2;
        }
      },
      maxIndex: 1500
    };

    function Particles(scene) {
      var geometry, i, material, mesh, r, th, tp, vertex, _i, _j, _k, _ref, _ref1, _ref2;
      this.scene = scene;
      this.geometries = [];
      for (tp = _i = 0, _ref = TYPE.numTypes; 0 <= _ref ? _i < _ref : _i > _ref; tp = 0 <= _ref ? ++_i : --_i) {
        geometry = new THREE.Geometry();
        for (i = _j = 0, _ref1 = TYPE.size(tp); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          r = Math.cos(Math.random() * 1.4) * 20;
          th = Math.random() * 100;
          vertex = new THREE.Vector3(Math.sin(th) * r, 0, Math.cos(th) * r);
          geometry.vertices.push(vertex);
        }
        this.geometries.push(geometry);
        console.info(geometry.vertices.length);
      }
      for (i = _k = 0, _ref2 = TYPE.numTypes; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
        material = TYPE.ind(i) === TYPE.tp1 ? new THREE.PointCloudMaterial({
          size: 1.0,
          map: this.makeTexture(TYPE.tp1),
          blending: THREE.AdditiveBlending,
          transparent: true,
          depthTest: false
        }) : TYPE.ind(i) === TYPE.tp2 ? new THREE.PointCloudMaterial({
          size: 4.0,
          map: this.makeTexture(TYPE.tp2),
          blending: THREE.AdditiveBlending,
          transparent: true,
          depthTest: false
        }) : TYPE.ind(i) === TYPE.tp3 ? new THREE.PointCloudMaterial({
          size: 10.0,
          map: this.makeTexture(TYPE.tp3),
          blending: THREE.AdditiveBlending,
          transparent: true,
          depthTest: false
        }) : void 0;
        mesh = new THREE.PointCloud(this.geometries[i], material);
        this.scene.add(mesh);
      }
    }

    Particles.prototype.makeTexture = function(tp) {
      var canvas, ctx, grad, height, texture, width;
      canvas = document.createElement('canvas');
      width = canvas.width = 256;
      height = canvas.height = 256;
      ctx = canvas.getContext('2d');
      if (tp === TYPE.tp1) {
        grad = ctx.createRadialGradient(width / 2, height / 2, width / 4, width / 2, height / 2, width / 2);
        grad.addColorStop(0, 'rgb(160, 255, 255)');
        grad.addColorStop(0.10, 'rgb(96, 128, 128)');
        grad.addColorStop(0.60, 'rgb(48, 48, 32)');
        grad.addColorStop(1, 'rgb(0, 0, 0)');
      } else if (tp === TYPE.tp2) {
        grad = ctx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, width / 2);
        grad.addColorStop(0, 'rgb(32, 32, 32)');
        grad.addColorStop(1, 'rgb(0, 0, 0)');
      } else if (tp === TYPE.tp3) {
        grad = ctx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, width / 2);
        grad.addColorStop(0, 'rgb(8, 8, 16)');
        grad.addColorStop(1, 'rgb(0, 0, 0)');
      }
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.rect(0, 0, width, height);
      ctx.fill();
      if (__DEBUG__) {
        document.body.appendChild(canvas);
      }
      texture = THREE.ImageUtils.loadTexture(canvas.toDataURL());
      return texture;
    };

    Particles.prototype.update = function() {
      var geometry, i, th, tp, u, vertex, _i, _j, _len, _len1, _ref, _ref1, _results;
      u = 0;
      _ref = this.geometries;
      _results = [];
      for (tp = _i = 0, _len = _ref.length; _i < _len; tp = ++_i) {
        geometry = _ref[tp];
        _ref1 = geometry.vertices;
        for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
          vertex = _ref1[i];
          u++;
          if (TYPE.ind(tp) === TYPE.tp1) {
            th = God.tick * 0.0005 + i;
            vertex.x += Math.sin(God.tick * 0.0005 + i) * 0.02;
            vertex.z += Math.cos(God.tick * 0.0005 + i * 2) * 0.02;
            vertex.y = Math.sin(th) * 20;
            if (Math.cos(th) < 0) {
              vertex.y *= -1;
            }
            if (vertex.y < 0) {
              vertex.y += 20;
            }
          } else if (TYPE.ind(tp) === TYPE.tp2) {
            God.grasses[i].position.copy(vertex);
          } else if (TYPE.ind(tp) === TYPE.tp3) {
            th = God.tick * 0.001 + i;
            vertex.y = Math.sin(th) * 2 + 4;
          }
        }
        _results.push(geometry.verticesNeedUpdate = true);
      }
      return _results;
    };

    return Particles;

  })();

  window.God = God;

}).call(this);

/*
//@ sourceMappingURL=grass.map
*/
